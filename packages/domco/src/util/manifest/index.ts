import { dirNames, fileNames } from "../../constants/index.js";
import { toAllScriptEndings, toPosix } from "../fs/index.js";
import type { Chunk } from "client:page";
import fs from "node:fs/promises";
import path from "node:path";
import type { Manifest, ManifestChunk } from "vite";

/**
 * Reads the manifest generated by the client build and creates
 * a string of <script> `tags` and `src` paths based on the
 * imports/hashed names.
 *
 * @param options
 * @returns The HTML <script> tags as a concatenated string and `src` paths.
 */
export const getChunk = async (options: {
	/** @example "/react" */
	pathName: string;

	/** Pass through Vite plugin `this.error` */
	error: (message: string) => never;

	/**
	 * If the pathname is an import. If so, it already is the full name.
	 * So there is no need to check the manifest for all the endings, we
	 * know it's already there.
	 */
	imp?: boolean;

	/** If the entry point is a page instead of a script. */
	page?: boolean;
}): Promise<Chunk> => {
	const { pathName, error, imp = false, page = false } = options;

	const manifest: Manifest = JSON.parse(
		await fs.readFile(
			path.join(
				dirNames.out.base,
				dirNames.out.client.base,
				".vite",
				"manifest.json",
			),
			"utf-8",
		),
	);

	let manifestChunk: ManifestChunk | undefined;

	if (imp) {
		manifestChunk = manifest[pathName];
	} else {
		// find chunk
		find: for (const [id, value] of Object.entries(manifest)) {
			const srcPath = toPosix(
				path.join(
					dirNames.src.client,
					pathName,
					page ? fileNames.page : fileNames.script,
				),
			);

			if (id === srcPath) {
				// pages have the .html ending
				// ex: "client/react/+page.html"
				manifestChunk = value;
				break;
			}

			if (!page) {
				// id is like this: "client/react/+script.tsx"
				// remove leading / , try all endings
				for (const idPath of toAllScriptEndings(srcPath)) {
					if (id === idPath) {
						manifestChunk = value;
						break find;
					}
				}
			}
		}
	}

	const chunk: Chunk = {
		tags: "",
		src: {
			src: "",
			file: "",
			module: [],
			preload: [],
			style: [],
			assets: [],
			dynamic: [],
		},
	};

	if (!manifestChunk) {
		error(`No tags found in manifest for \`${pathName}\``);
		return chunk;
	}

	chunk.src.src = manifestChunk.src ?? "";
	chunk.src.file = manifestChunk.file;

	if (!imp) {
		// the entry file name
		chunk.tags += `<script type="module" src="/${manifestChunk.file}"></script>`;
		chunk.src.module.push("/" + manifestChunk.file);
	} else {
		// a modulepreload link to get the script ready but don't execute immediately
		// this is required to flatten the request waterfall if you are using manual chunks for example
		chunk.tags += `<link rel="modulepreload" crossorigin href="/${manifestChunk.file}">`;
		chunk.src.preload.push("/" + manifestChunk.file);
	}

	if (manifestChunk.css) {
		// need to also do this for `imports` since css does not actually link in the code
		for (const cssFile of manifestChunk.css) {
			chunk.tags += `<link rel="stylesheet" href="/${cssFile}">`;
			chunk.src.style.push("/" + cssFile);
		}
	}

	if (manifestChunk.assets) {
		chunk.src.assets.push(...manifestChunk.assets);
	}

	if (manifestChunk.dynamicImports) {
		for (const impPathName of manifestChunk.dynamicImports) {
			const impChunk = await getChunk({
				pathName: impPathName,
				imp: true,
				error,
			});

			// dynamic chunks are not added to tags or flattened
			// just pushed directly. You may not want to request them
			// unless they are truly needed.
			chunk.src.dynamic.push(impChunk);
		}
	}

	if (manifestChunk.imports) {
		// recursively call on imports
		for (const impPathName of manifestChunk.imports) {
			const impChunk = await getChunk({
				pathName: impPathName,
				imp: true,
				error,
			});

			chunk.tags += impChunk.tags;
			chunk.src.module.push(...impChunk.src.module);
			chunk.src.preload.push(...impChunk.src.preload);
			chunk.src.style.push(...impChunk.src.style);
			chunk.src.assets.push(...impChunk.src.assets);
			chunk.src.dynamic.push(...impChunk.src.dynamic);
		}
	}

	return chunk;
};
