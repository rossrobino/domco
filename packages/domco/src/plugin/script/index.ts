import { dirNames, fileNames } from "../../constants/index.js";
import { findFiles, toAllScriptEndings, toPosix } from "../../util/fs/index.js";
import fs from "node:fs/promises";
import path from "node:path";
import type { Manifest, ManifestChunk, Plugin } from "vite";

/**
 * Creates the `client:script` virtual module.
 *
 * @returns Vite plugin
 */
export const scriptPlugin = (): Plugin => {
	const scriptId = "client:script";
	const resolvedScriptId = `\0${scriptId}`;

	let prod: boolean | undefined;

	return {
		name: `domco:${scriptId}`,
		config(_config, env) {
			prod = env.mode === "production";
		},

		resolveId(id) {
			if (id.startsWith(scriptId)) {
				// Don't return the resolved id here, needs to be the full path.
				return `\0${id}`;
			}
		},

		async load(id) {
			if (id.startsWith(resolvedScriptId)) {
				let pathName = id.slice(resolvedScriptId.length);

				// remove trailing slash
				if (pathName.endsWith("/")) pathName = pathName.slice(0, -1);

				if (!pathName) pathName = "/";

				if (!prod) {
					const scriptFiles = await findFiles({
						dir: `${dirNames.src.base}/${dirNames.src.client}`,
						checkEndings: toAllScriptEndings(fileNames.script),
					});

					// link the script from src
					let src = scriptFiles[pathName]?.slice(
						`/${dirNames.src.base}`.length,
					);

					if (!src) {
						this.warn(`No client module found for ${pathName}`);
						src = "";
					}

					return getTags({
						tags: `<script type="module" src="${src}"></script>`,
						src: { module: [src], preload: [], style: [] },
					});
				} else {
					// read from manifest
					const manifest: Manifest = JSON.parse(
						await fs.readFile(
							path.join(
								dirNames.out.base,
								dirNames.out.client.base,
								".vite",
								"manifest.json",
							),
							"utf-8",
						),
					);

					return getTags(getMeta({ manifest, pathName, error: this.error }));
				}
			}
		},
	};
};

const getTags = (meta: ReturnType<typeof getMeta>) => {
	let code = `export const tags = ${JSON.stringify(meta.tags)};\n`;
	code += `export const src = ${JSON.stringify(meta.src)};\n`;

	return code;
};

// update env types if this changes
// TODO figure out the proper way to import into d.ts
type Meta = {
	tags: string;
	src: { module: string[]; preload: string[]; style: string[] };
};

/**
 * Reads the manifest generated by the client build and creates
 * a string of <script> `tags` and `src` paths based on the
 * imports/hashed names.
 *
 * @param options
 * @returns The HTML <script> tags as a concatenated string and `src` paths.
 */
const getMeta = (options: {
	/** The vite manifest generated from the client build. */
	manifest: Manifest;

	/** @example "/react" */
	pathName: string;

	/**
	 * If the pathname is an import. If so, it already is the full name.
	 * So there is no need to check the manifest for all the endings, we
	 * know it's already there.
	 */
	imp?: boolean;

	error: (message: string) => never;
}): Meta => {
	const { manifest, pathName, error, imp = false } = options;

	let chunk: ManifestChunk | undefined;

	if (imp) {
		chunk = manifest[pathName];
	} else {
		// find chunk
		for (const [id, value] of Object.entries(manifest)) {
			if (chunk) break;

			const noEnding = toPosix(
				path.join(dirNames.src.client, pathName, fileNames.script),
			);

			// id is like this: "client/react/+script.tsx"
			// remove leading / , try all endings
			for (const idPath of toAllScriptEndings(noEnding)) {
				if (chunk) break;

				if (id === idPath) {
					chunk = value;
				}
			}
		}
	}

	const meta: Meta = { tags: "", src: { module: [], preload: [], style: [] } };

	if (!chunk) {
		error(`No tags found in manifest for \`${pathName}\``);
		return meta;
	}

	if (!imp) {
		// the entry file name
		meta.tags += `<script type="module" src="/${chunk.file}"></script>`;
		meta.src.module.push("/" + chunk.file);
	} else {
		// a modulepreload link to get the script ready but don't execute immediately
		// this is required to flatten the request waterfall if you are using manual chunks for example
		meta.tags += `<link rel="modulepreload" crossorigin href="/${chunk.file}">`;
		meta.src.preload.push("/" + chunk.file);
	}

	if (chunk.css) {
		// need to also do this for `imports` since css does not actually link in the code
		for (const cssFile of chunk.css) {
			meta.tags += `<link rel="stylesheet" href="/${cssFile}">`;
			meta.src.style.push("/" + cssFile);
		}
	}

	if (chunk.imports) {
		// recursively call on imports
		for (const impPathName of chunk.imports) {
			const meta = getMeta({
				manifest,
				pathName: impPathName,
				imp: true,
				error,
			});

			meta.tags += meta.tags;
			meta.src.module.push(...meta.src.module);
			meta.src.preload.push(...meta.src.preload);
			meta.src.style.push(...meta.src.style);
		}
	}

	return meta;
};
