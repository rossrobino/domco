import { dirNames, fileNames } from "../../constants/index.js";
import { serializeTags, type TagDescriptor } from "../../injector/index.js";
import { findFiles, toAllScriptEndings, toPosix } from "../../util/fs/index.js";
import fs from "node:fs/promises";
import path from "node:path";
import type { Manifest, ManifestChunk, Plugin } from "vite";

/**
 * Creates the `client:script` virtual module.
 *
 * @returns Vite plugin
 */
export const scriptPlugin = (): Plugin => {
	const scriptId = "client:script";
	const resolvedScriptId = `\0${scriptId}`;

	let prod: boolean | undefined;

	return {
		name: `domco:${scriptId}`,
		config(_config, env) {
			prod = env.mode === "production";
		},

		resolveId(id) {
			if (id.startsWith(scriptId)) {
				// Don't return the resolved id here, needs to be the full path.
				return `\0${id}`;
			}
		},

		async load(id) {
			if (id.startsWith(resolvedScriptId)) {
				let pathName = id.slice(resolvedScriptId.length);

				// remove trailing slash
				if (pathName.endsWith("/")) pathName = pathName.slice(0, -1);

				if (!pathName) pathName = "/";

				const tags: TagDescriptor[] = [];

				if (!prod) {
					const scriptFiles = await findFiles({
						dir: `${dirNames.src.base}/${dirNames.src.client}`,
						checkEndings: toAllScriptEndings(fileNames.script),
					});

					// link the script from src
					const src = scriptFiles[pathName]?.slice(
						`/${dirNames.src.base}`.length,
					);

					if (!src) this.warn(`No client module found for ${pathName}`);

					tags.push({
						tag: "script",
						attrs: { type: "module", src },
					});
				} else {
					// read from manifest
					const manifest: Manifest = JSON.parse(
						await fs.readFile(
							path.join(
								dirNames.out.base,
								dirNames.out.client.base,
								".vite",
								"manifest.json",
							),
							"utf-8",
						),
					);

					tags.push(...getTags({ manifest, pathName, error: this.error }));
				}

				return `export const tags = ${JSON.stringify(serializeTags(tags))};`;
			}
		},
	};
};

/**
 * Reads the manifest generated by the client build and creates
 * a string of <script> tags based on the imports/hashed names.
 *
 * @param options
 * @returns The HTML <script> tags as a concatenated string.
 */
const getTags = (options: {
	/** The vite manifest generated from the client build. */
	manifest: Manifest;

	/** @example "/react" */
	pathName: string;

	/**
	 * If the pathname is an import. If so, it already is the full name.
	 * So there is no need to check the manifest for all the endings, we
	 * know it's already there.
	 */
	imp?: boolean;

	error: (message: string) => never;
}) => {
	const { manifest, pathName, error, imp = false } = options;

	let chunk: ManifestChunk | undefined;

	if (imp) {
		chunk = manifest[pathName];
	} else {
		// find chunk
		for (const [id, value] of Object.entries(manifest)) {
			if (chunk) break;

			const noEnding = toPosix(
				path.join(dirNames.src.client, pathName, fileNames.script),
			);

			// id is like this: "client/react/+script.tsx"
			// remove leading / , try all endings
			for (const idPath of toAllScriptEndings(noEnding)) {
				if (chunk) break;

				if (id === idPath) {
					chunk = value;
				}
			}
		}
	}

	if (!chunk) {
		error(`No tags found in manifest for \`${pathName}\``);
		return [];
	}

	const tags: TagDescriptor[] = [];

	if (!imp) {
		// push the entry file name
		tags.push({
			tag: "script",
			attrs: { type: "module", src: `/${chunk.file}` },
		});
	} else {
		// push a modulepreload link to get the script ready but don't execute immediately
		// this is required to flatten the request waterfall if you are using manual chunks for example
		tags.push({
			tag: "link",
			attrs: {
				rel: "modulepreload",
				crossorigin: "",
				href: `/${chunk.file}`,
			},
		});
	}

	if (chunk.css) {
		// need to also do this for `imports` since css does not actually link in the code
		for (const cssFile of chunk.css) {
			tags.push({
				tag: "link",
				attrs: { rel: "stylesheet", href: `/${cssFile}` },
			});
		}
	}

	if (chunk.imports) {
		// recursively call on imports
		for (const impPathName of chunk.imports) {
			tags.push(
				...getTags({
					manifest,
					pathName: impPathName,
					imp: true,
					error,
				}),
			);
		}
	}

	return tags;
};
