/**
 * https://vercel.com/docs/build-output-api/v3/primitives#serverless-function-configuration
 */
export type ServerlessFunctionConfig = {
	/**
	 * Indicates the initial file where code will be executed for the Serverless Function.
	 */
	handler: string;
	/**
	 * Specifies which "runtime" will be used to execute the Serverless Function.
	 * See [Runtimes](https://vercel.com/docs/functions/serverless-functions/runtimes) for more information.
	 *
	 * @default "nodejs20.x"
	 */
	runtime: "nodejs20.x";
	/**
	 * Amount of memory (RAM in MB) that will be allocated to the Serverless Function.
	 * See [size limits](https://vercel.com/docs/functions/serverless-functions/runtimes#size-limits) for more information.
	 */
	memory?: number;
	/**
	 * Maximum duration (in seconds) that will be allowed for the Serverless Function.
	 * See [size limits](https://vercel.com/docs/functions/serverless-functions/runtimes#size-limits) for more information.
	 */
	maxDuration?: number;
	/**
	 * Map of additional environment variables that will be available to the Serverless Function,
	 * in addition to the env vars specified in the Project Settings.
	 */
	environment?: Record<string, string>[];
	/**
	 * List of Vercel [Regions](https://vercel.com/docs/concepts/edge-network/regions)
	 * where the Serverless Function will be deployed to.
	 */
	regions?: string[];
	/**
	 * True if a custom runtime has support for Lambda runtime wrappers.
	 */
	supportsWrapper?: boolean;
	/**
	 * When true, the Serverless Function will stream the response to the client.
	 */
	supportsResponseStreaming?: boolean;
};

export type NodejsServerlessFunctionConfig = ServerlessFunctionConfig & {
	/**
	 * Specifies which launcher to use. Currently only "Nodejs" is supported.
	 *
	 * @default "Nodejs"
	 */
	launcherType: "Nodejs";
	/**
	 * Enables request and response helpers methods.
	 *
	 * @default false
	 */
	shouldAddHelpers?: boolean;
	/**
	 * Enables source map generation.
	 *
	 * @default false
	 */
	shouldAddSourceMapSupport?: boolean;
};

export type PrerenderFunctionConfig = {
	/**
	 * Expiration time (in seconds) before the cached asset will be re-generated by invoking the Serverless Function.
	 * Setting the value to `false` means it will never expire.
	 *
	 * @example (one day)
	 *
	 * 60 * 60 * 24
	 */
	expiration: number | false;
	/**
	 * Option group number of the asset.
	 * Prerender assets with the same group number will all be re-validated at the same time.
	 */
	group?: number;
	/**
	 * Random token assigned to the `__prerender_bypass` cookie when [Draft Mode](https://vercel.com/docs/workflow-collaboration/draft-mode) is enabled,
	 * in order to safely bypass the Edge Network cache
	 */
	bypassToken?: string;
	/**
	 * Name of the optional fallback file relative to the configuration file.
	 */
	fallback?: string;
	/**
	 * List of query string parameter names that will be cached independently.
	 * If an empty array, query values are not considered for caching.
	 * If undefined each unique query value is cached independently
	 */
	allowQuery?: string[];
	/**
	 * 	When true, the query string will be present on the request argument passed to the invoked function.
	 * The allowQuery filter still applies.
	 */
	passQuery?: boolean;
};

export type EdgeFunctionConfig = {
	/**
	 * The runtime: "edge" property is required to indicate that this directory represents an Edge Function.
	 */
	runtime: "edge";
	/**
	 * Indicates the initial file where code will be executed for the Edge Function.
	 */
	entrypoint: string;
	/**
	 * List of environment variable names that will be available for the Edge Function to utilize.
	 */
	envVarsInUse?: string[];
	/**
	 * List of regions or a specific region that the edge function will be available in, defaults to all.
	 * [View regions](https://vercel.com/docs/edge-network/regions#region-list)
	 */
	regions?: "all" | string | string[];
};

export type OutputConfig = {
	version: 3;
	routes?: Route[];
	images?: ImagesConfig;
	wildcard?: WildcardConfig;
	overrides?: OverrideConfig;
	cache?: Cache;
	crons?: CronsConfig;
	framework?: Framework;
};

type Route = Source | Handler;

type Source = {
	src: string;
	dest?: string;
	headers?: Record<string, string>;
	methods?: string[];
	continue?: boolean;
	caseSensitive?: boolean;
	check?: boolean;
	status?: number;
	has?: Array<HostHasField | HeaderHasField | CookieHasField | QueryHasField>;
	missing?: Array<
		HostHasField | HeaderHasField | CookieHasField | QueryHasField
	>;
	locale?: Locale;
	middlewareRawSrc?: string[];
	middlewarePath?: string;
};

type Locale = {
	redirect?: Record<string, string>;
	cookie?: string;
};

type HostHasField = {
	type: "host";
	value: string;
};

type HeaderHasField = {
	type: "header";
	key: string;
	value?: string;
};

type CookieHasField = {
	type: "cookie";
	key: string;
	value?: string;
};

type QueryHasField = {
	type: "query";
	key: string;
	value?: string;
};

type HandleValue =
	| "rewrite"
	| "filesystem" // check matches after the filesystem misses
	| "resource"
	| "miss" // check matches after every filesystem miss
	| "hit"
	| "error"; //  check matches after error (500, 404, etc.)

type Handler = {
	handle: HandleValue;
	src?: string;
	dest?: string;
	status?: number;
};

type ImageFormat = "image/avif" | "image/webp";

type RemotePattern = {
	protocol?: "http" | "https";
	hostname: string;
	port?: string;
	pathname?: string;
};

type ImagesConfig = {
	sizes: number[];
	domains: string[];
	remotePatterns?: RemotePattern[];
	minimumCacheTTL?: number; // seconds
	formats?: ImageFormat[];
	dangerouslyAllowSVG?: boolean;
	contentSecurityPolicy?: string;
	contentDispositionType?: string;
};

type WildCard = {
	domain: string;
	value: string;
};

type WildcardConfig = Array<WildCard>;

type Override = {
	path?: string;
	contentType?: string;
};

type OverrideConfig = Record<string, Override>;

type Cache = string[];

type Framework = {
	slug: string;
	version: string;
};

type Cron = {
	path: string;
	schedule: string;
};

type CronsConfig = Cron[];
