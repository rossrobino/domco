import { dirNames } from "../../constants/index.js";
import type { AdapterBuilder } from "../../types/public/index.js";
import {
	clearDir,
	copyClient,
	copyServer,
	toPosix,
} from "../../util/fs/index.js";
import fs from "node:fs/promises";
import path from "node:path";

/**
 * Creates a Cloudflare Pages build.
 *
 * @param options adapter options
 * @returns Cloudflare domco adapter.
 *
 * @example
 *
 * ```ts
 * import { domco } from "domco";
 * import { adapter } from "domco/adapter/cloudflare";
 * import { defineConfig } from "vite";
 *
 * export default defineConfig({
 * 	plugins: [
 * 		domco({
 * 			adapter: adapter(),
 * 		}),
 * 	],
 * });
 * ```
 */
export const adapter: AdapterBuilder = async () => {
	return {
		name: "cloudflare",

		message: `created Cloudflare Pages build .cloudflare/`,

		entry: ({ appId }) => {
			return {
				id: "_worker",
				code: `
					import { createApp } from "${appId}";
					
					const app = createApp();
					
					export default app;
				`,
			};
		},

		ssrTarget: "webworker",

		run: async () => {
			const outDir = ".cloudflare";

			// const packageJson = await fs.readFile("package.json", "utf-8");
			// const { name } = JSON.parse(packageJson);

			// const wranglerToml = {
			// 	filePath: path.join(process.cwd(), "wrangler.toml"),
			// 	toml: `name = "${name}"\ncompatibility_date = "2024-09-05"\npages_build_output_dir= "./${outDir}"\n`,
			// };

			const routes = {
				version: 1,
				description: "Generated by `domco/adapter/cloudflare`.",
				include: ["/*"],
				exclude: [`/${dirNames.out.client.immutable}/*`],
			};

			/**
			 * Adds paths to exclude from when the worker gets called.
			 *
			 * @param dir directory to walk
			 */
			const addExclusions = async (dir?: string) => {
				const base = path.join(
					process.cwd(),
					dirNames.out.base,
					dirNames.out.client.base,
				);

				if (!dir) dir = base;

				const staticFiles = await fs.readdir(dir, { withFileTypes: true });

				for (const file of staticFiles) {
					const filePath = path.join(dir, file.name);
					let relativePath = toPosix(`/${path.relative(base, filePath)}`);

					if (
						relativePath.startsWith(`/${dirNames.out.client.immutable}`) ||
						relativePath.startsWith("/.vite")
					) {
						// already added via wildcard
						continue;
					}

					if (file.isDirectory()) {
						await addExclusions(filePath);
						continue;
					}

					if (relativePath.endsWith("index.html")) {
						// remove "index.html" from end
						relativePath = relativePath.slice(0, -11);
						if (relativePath === "") {
							relativePath = "/";
						}
					} else if (relativePath.endsWith("html")) {
						// remove ".html" from end
						relativePath = relativePath.slice(0, -5);
					}

					routes.exclude.push(relativePath);
				}
			};

			await addExclusions();

			await clearDir(outDir);

			// if (!(await fileExists(wranglerToml.filePath))) {
			// 	await fs.writeFile(wranglerToml.filePath, wranglerToml.toml);
			// }

			await Promise.all([
				copyClient(outDir),
				copyServer(outDir),
				fs.writeFile(
					path.join(outDir, "_routes.json"),
					JSON.stringify(routes, null, "\t"),
				),
			]);
		},
	};
};
